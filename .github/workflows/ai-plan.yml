name: AI Plan

on:
  issues:
    types: [labeled]

concurrency:
  group: ai-${{ github.repository }}
  cancel-in-progress: false

permissions:
  issues: write
  contents: write

jobs:
  plan-consensus:
    if: github.event.label.name == 'ai-task'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Read AI config
        id: config
        run: |
          if [ -f .ai/config.json ]; then
            echo "max_iterations=$(jq -r '.max_plan_iterations // 3' .ai/config.json)" >> "$GITHUB_OUTPUT"
            echo "dev_branch=$(jq -r '.dev_branch // "main"' .ai/config.json)" >> "$GITHUB_OUTPUT"
          else
            echo "max_iterations=3" >> "$GITHUB_OUTPUT"
            echo "dev_branch=main" >> "$GITHUB_OUTPUT"
          fi

      - name: Swap labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit "${{ github.event.issue.number }}" \
            --remove-label "ai-task" --add-label "planning"

      - name: Gather repo context
        run: |
          find . -type f \
            -not -path './.git/*' \
            -not -path './node_modules/*' \
            -not -path './target/*' \
            -not -path './dist/*' \
            -not -path './build/*' \
            -not -path './vendor/*' \
            -not -path './.ai/*' \
            | sort | head -300 > /tmp/file_tree.txt

      - name: Run planning consensus loop
        id: consensus
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
          MAX_ITERATIONS: ${{ steps.config.outputs.max_iterations }}
        run: |
          set -euo pipefail

          ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title -q '.title')
          ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body -q '.body')
          FILE_TREE=$(cat /tmp/file_tree.txt)

          AGENTS_CONTEXT=""
          if [ -f AGENTS.md ]; then
            AGENTS_CONTEXT=$(cat AGENTS.md)
          fi

          ITERATION=0
          APPROVED=false
          PLAN=""
          CRITIQUE=""

          # ── API call with retry + exponential backoff ──
          api_call_with_retry() {
            local url="$1"
            shift
            local max_retries=3
            local delay=5
            for attempt in $(seq 1 $max_retries); do
              local response
              if response=$(curl -sf --max-time 120 "$url" "$@" 2>/dev/null); then
                echo "$response"
                return 0
              fi
              if [ "$attempt" -lt "$max_retries" ]; then
                echo "API call failed (attempt $attempt/$max_retries), retrying in ${delay}s..." >&2
                sleep "$delay"
                delay=$((delay * 2))
              fi
            done
            echo ""
            return 1
          }

          call_claude() {
            local prompt="$1"
            local payload
            payload=$(jq -n --arg content "$prompt" '{
              "model": "claude-sonnet-4-20250514",
              "max_tokens": 4096,
              "messages": [{"role": "user", "content": $content}]
            }')
            local response
            response=$(api_call_with_retry "https://api.anthropic.com/v1/messages" \
              -H "x-api-key: $ANTHROPIC_API_KEY" \
              -H "anthropic-version: 2023-06-01" \
              -H "content-type: application/json" \
              -d "$payload")
            echo "$response" | jq -r '.content[0].text // empty'
          }

          call_codex() {
            local prompt="$1"
            local payload
            payload=$(jq -n --arg content "$prompt" '{
              "model": "gpt-4o",
              "max_tokens": 4096,
              "messages": [{"role": "user", "content": $content}]
            }')
            local response
            response=$(api_call_with_retry "https://api.openai.com/v1/chat/completions" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "content-type: application/json" \
              -d "$payload")
            echo "$response" | jq -r '.choices[0].message.content // empty'
          }

          # ── Robust APPROVE/REJECT parser ──
          # Handles: whitespace, markdown formatting, code blocks, quoted replies
          parse_verdict() {
            local text="$1"
            # Strip markdown formatting, code blocks, quoted lines, leading whitespace
            local cleaned
            cleaned=$(echo "$text" | \
              sed 's/^> .*//' | \
              sed 's/^```.*$//' | \
              sed 's/\*\*//g' | \
              sed 's/^[[:space:]]*//' | \
              tr -s '[:space:]')
            # Get first non-empty word, uppercase
            local first_word
            first_word=$(echo "$cleaned" | awk 'NF{print toupper($1); exit}')
            # Normalize common variants
            case "$first_word" in
              APPROVE|APPROVED|LGTM) echo "APPROVE" ;;
              REJECT|REJECTED)       echo "REJECT" ;;
              *)                     echo "UNKNOWN" ;;
            esac
          }

          while [ "$ITERATION" -lt "$MAX_ITERATIONS" ] && [ "$APPROVED" != "true" ]; do
            ITERATION=$((ITERATION + 1))
            echo "=== Planning iteration $ITERATION/$MAX_ITERATIONS ==="

            # ── Claude generates/revises plan ──
            if [ "$ITERATION" -eq 1 ]; then
              CLAUDE_PROMPT="You are analyzing a GitHub issue to create an implementation plan.

          Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}

          ${ISSUE_BODY}

          Repository context:
          ${AGENTS_CONTEXT}

          Repository file tree:
          ${FILE_TREE}

          Output a plan as a SINGLE fenced JSON code block (\`\`\`json ... \`\`\`) with this exact schema:
          {
            \"summary\": \"one paragraph describing the change\",
            \"files_allowed\": [\"path/to/file\"],
            \"changes\": [{\"file\": \"path/to/file\", \"intent\": \"what this change does\", \"risk\": \"what could break\"}],
            \"tests_required\": [{\"command\": \"npm test\", \"purpose\": \"what it proves\"}],
            \"invariants\": [\"truth that must remain true after this change\"],
            \"risk_level\": \"low|medium|high\"
          }

          Rules:
          - files_allowed MUST list every file that will be created or modified
          - Each change must reference a real file path from the tree above
          - tests_required must include at least one test command
          - invariants should capture behavior that must not break
          - Your response MUST contain exactly one fenced JSON code block"
            else
              CLAUDE_PROMPT="Codex reviewed your plan and proposed these changes:

          ${CRITIQUE}

          Your previous plan:
          \`\`\`json
          ${PLAN}
          \`\`\`

          Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}

          Revise your plan to address the valid critique points. Output the revised plan as a SINGLE fenced JSON code block (\`\`\`json ... \`\`\`) with the same schema. Keep the same structure but incorporate valid feedback."
            fi

            echo "Calling Claude..."
            CLAUDE_RESPONSE=$(call_claude "$CLAUDE_PROMPT")

            if [ -z "$CLAUDE_RESPONSE" ]; then
              gh issue comment "$ISSUE_NUMBER" --body $'**AI Plan Error:** Claude returned an empty response on iteration '"$ITERATION"$'. Manual intervention required.'
              gh issue edit "$ISSUE_NUMBER" --remove-label "planning" --add-label "halted"
              exit 1
            fi

            # Extract JSON from fenced code block
            PLAN=$(echo "$CLAUDE_RESPONSE" | sed -n '/^```json/,/^```$/p' | sed '1d;$d')

            if [ -z "$PLAN" ] || ! echo "$PLAN" | jq empty 2>/dev/null; then
              gh issue comment "$ISSUE_NUMBER" --body "**AI Plan Error:** Could not extract valid JSON from Claude's response (iteration $ITERATION).

          <details><summary>Raw response</summary>

          $CLAUDE_RESPONSE

          </details>"
              gh issue edit "$ISSUE_NUMBER" --remove-label "planning" --add-label "halted"
              exit 1
            fi

            # Post plan as comment
            PLAN_PRETTY=$(echo "$PLAN" | jq .)
            gh issue comment "$ISSUE_NUMBER" --body "**Claude Plan (iteration ${ITERATION}/${MAX_ITERATIONS}):**

          \`\`\`json
          ${PLAN_PRETTY}
          \`\`\`"

            # ── Codex critiques plan ──
            CODEX_PROMPT="You are a code reviewer evaluating an implementation plan.

          Original issue: ${ISSUE_TITLE}
          ${ISSUE_BODY}

          Proposed plan:
          ${PLAN_PRETTY}

          Evaluate ONLY for blocking issues:
          1. Are any required files MISSING from files_allowed?
          2. Are there changes that would BREAK existing functionality?
          3. Is the plan fundamentally WRONG about what needs to change?
          4. Are there SECURITY risks not addressed?

          IMPORTANT: You MUST start your response with either APPROVE or REJECT.

          Reply APPROVE if the plan is fundamentally sound and implementable, even if you have minor suggestions. Minor style preferences, edge cases, or nice-to-haves are NOT grounds for rejection.

          Reply REJECT only if there are blocking issues that would cause the implementation to fail or break production. After REJECT, list ONLY the blocking issues."

            echo "Calling Codex..."
            CRITIQUE=$(call_codex "$CODEX_PROMPT")

            if [ -z "$CRITIQUE" ]; then
              gh issue comment "$ISSUE_NUMBER" --body "**AI Plan Error:** Codex returned an empty response on iteration $ITERATION. Manual intervention required."
              gh issue edit "$ISSUE_NUMBER" --remove-label "planning" --add-label "halted"
              exit 1
            fi

            # Post critique as comment
            gh issue comment "$ISSUE_NUMBER" --body "**Codex Critique (iteration ${ITERATION}/${MAX_ITERATIONS}):**

          ${CRITIQUE}"

            # Check verdict with robust parser
            VERDICT=$(parse_verdict "$CRITIQUE")
            echo "Parsed verdict: $VERDICT"
            if [ "$VERDICT" = "APPROVE" ]; then
              APPROVED=true
              echo "Plan approved on iteration $ITERATION"
            else
              echo "Plan not approved ($VERDICT), will revise"
            fi
          done

          if [ "$APPROVED" = "true" ]; then
            # Inject issue number and metadata for traceability
            FINAL_PLAN=$(echo "$PLAN" | jq \
              --argjson num "$ISSUE_NUMBER" \
              --arg repo "$REPO" \
              --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --argjson iter "$ITERATION" \
              '. + {issue_number: $num, repository: $repo, locked_at: $ts, iterations: $iter}')
            echo "$FINAL_PLAN" > /tmp/plan.json
            echo "approved=true" >> "$GITHUB_OUTPUT"
          else
            gh issue comment "$ISSUE_NUMBER" --body "**Plan consensus failed** after $MAX_ITERATIONS iterations. Manual intervention required.

          Remove the \`halted\` label and add \`ai-task\` to restart planning, or resolve the issue manually."
            gh issue edit "$ISSUE_NUMBER" --remove-label "planning" --add-label "halted"
            echo "approved=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit locked plan
        if: steps.consensus.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          DEV_BRANCH: ${{ steps.config.outputs.dev_branch }}
        run: |
          git fetch origin "$DEV_BRANCH"
          git checkout "$DEV_BRANCH"

          mkdir -p .ai
          cp /tmp/plan.json .ai/plan.locked.json

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .ai/plan.locked.json
          git commit -m "ai: lock plan for issue #$ISSUE_NUMBER"
          git push origin "$DEV_BRANCH"

      - name: Finalize labels
        if: steps.consensus.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit "${{ github.event.issue.number }}" \
            --remove-label "planning" --add-label "plan-approved"

      # ── Implementation phase (chained directly since GITHUB_TOKEN labels
      #    don't trigger other workflows) ──
      - name: Create implementation branch
        if: steps.consensus.outputs.approved == 'true'
        id: branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          DEV_BRANCH: ${{ steps.config.outputs.dev_branch }}
        run: |
          BRANCH="ai/issue-${ISSUE_NUMBER}"
          git fetch origin "$DEV_BRANCH"
          git checkout -b "$BRANCH" "origin/$DEV_BRANCH"
          git push -u origin "$BRANCH"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Update labels to implementing
        if: steps.consensus.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit "${{ github.event.issue.number }}" \
            --remove-label "plan-approved" --add-label "implementing"

      - name: Post implementation instruction for Codex
        if: steps.consensus.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          DEV_BRANCH: ${{ steps.config.outputs.dev_branch }}
          BRANCH: ${{ steps.branch.outputs.branch }}
        run: |
          PLAN=$(cat .ai/plan.locked.json)
          FILES_ALLOWED=$(echo "$PLAN" | jq -r '.files_allowed[]' | paste -sd ', ' -)
          TESTS=$(echo "$PLAN" | jq -r '.tests_required[].command' | paste -sd ', ' -)
          SUMMARY=$(echo "$PLAN" | jq -r '.summary')

          gh issue comment "$ISSUE_NUMBER" --body "@codex Implement the locked plan on branch \`$BRANCH\`.

          **Summary:** $SUMMARY
          **Target branch:** \`$DEV_BRANCH\`
          **Allowed files:** $FILES_ALLOWED
          **Required tests:** $TESTS

          Instructions:
          1. Check out branch \`$BRANCH\`
          2. Read the full plan from \`.ai/plan.locked.json\`
          3. Implement ALL changes listed in the plan
          4. ONLY modify files listed in \`files_allowed\`
          5. Run all tests listed in \`tests_required\`
          6. Create a PR from \`$BRANCH\` to \`$DEV_BRANCH\`

          <details><summary>Full plan</summary>

          \`\`\`json
          $(echo "$PLAN" | jq .)
          \`\`\`

          </details>"

      # ── Audit: upload plan and workflow metadata as artifact ──
      - name: Save audit trail
        if: always()
        run: |
          mkdir -p /tmp/audit
          echo "${{ github.event.issue.number }}" > /tmp/audit/issue_number.txt
          echo "${{ github.run_id }}" > /tmp/audit/workflow_run_id.txt
          echo "${{ github.repository }}" > /tmp/audit/repository.txt
          date -u +%Y-%m-%dT%H:%M:%SZ > /tmp/audit/timestamp.txt
          cp /tmp/plan.json /tmp/audit/plan.locked.json 2>/dev/null || echo '{"error":"no plan produced"}' > /tmp/audit/plan.locked.json

      - name: Upload audit artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ai-plan-audit-${{ github.event.issue.number }}
          path: /tmp/audit/
          retention-days: 90
